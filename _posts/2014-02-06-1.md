---
layout: post
title: '基于keepalived的同质客户端HA方案'
description: ""
category: 
tags: [keepalived,Ngnix ,HA]
theme :
  name : twitter
---
{% include JB/setup %}

=====先吐嘈======

	周五我的一篇通过招聘简章的描述分析用人单位用人需求的文章。因为被误当作非法招聘而删除。 心里很不爽。

========下面是正文==========

keepalived来做HA方案已经很成熟了，但基本都是对服务端做HA，比如Ngnix，通过服务端的冗余来消除单点故障。但也有很多场景需要对客户端做HA.

比如最近工作就遇到了：

	各个省公司要给集团公司发送非常重要的实时告警数据，要求很高的及时性，并且不可重复发送，不可漏发。 同时要接受收集团下发数据。

就这个需求，服务端接收集团数据使用keepaived+ngnix做HA。但客户端却遇到了麻烦：为避免重复发送，同一时刻只能有一个客户端给集团发告警。

	如果采用冷互备，同一时刻只启动一台客户机，VIP飘移时拉起Master主机的客户端进程，显得有些笨拙，实时性也很难满足要求。
	如果采用热互备，同时保证只有一台客户机工作，客户端就要实现复杂的分布式选举功能。用ZooKeeper的话，又觉得方案有些太重了。

今天想到一个比较巧的方案，基于keepalived的VIP飘移，同时代码也容易理解和实现 。

<img src="/assets/images/0e9e8bf8-72a1-38b0-8c01-a3240f8edc32.png" ></img>
如上图：
1. 每个客户启动后将获得一个唯一的ID ，如UUID .
2. 每个客户端开启一个监听端口Port。
3. 每个客户端持续的给VIP:Port发送{UUID}消息。接收到{UUID}的客户端，则说明是Master,如果该UUID与自己的UUID相同，开始给集团发送告警。
 
keepalived用来监视客户端的活跃状态。
